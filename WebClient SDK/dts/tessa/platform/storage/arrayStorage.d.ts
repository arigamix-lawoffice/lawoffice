import { IAtom } from 'mobx';
import { IStorageArray } from './storage';
import { IStorageArrayProvider } from './storageArrayProvider';
import { IStorageCachePolicyProvider } from './storageCachePolicyProvider';
import { IStorageNotificationReciever } from './storageNotificationReciever';
import { IStorageValueFactory } from './storageValueFactory';
import { ICloneable } from 'tessa/platform/cloneable';
import { EventHandler } from 'tessa/platform/eventHandler';
import { ValidationObject } from 'tessa/platform/validation/validationObject';
export interface CollectionChangedEventArgs<T> {
    storage: ArrayStorage;
    index: number;
    added: T[];
    removed: T[];
}
export declare class ArrayStorage<T = any> extends ValidationObject implements Array<T>, IStorageArrayProvider, IStorageCachePolicyProvider, ICloneable<ArrayStorage<T>>, IStorageNotificationReciever {
    constructor(storage: IStorageArray, defaultValueFactory?: IStorageValueFactory<T> | null, atomDisabled?: boolean);
    protected _storage: IStorageArray;
    protected _atom: IAtom;
    protected _atomDisabled: boolean;
    protected _cachedMembers: Map<any, T>;
    protected _defaultValueFactory: IStorageValueFactory<T>;
    get defaultValueFactory(): IStorageValueFactory<T> | undefined;
    get isTypedStorage(): boolean;
    protected spliceInternal(start: number, deleteCount: number, ...items: T[]): {
        added: T[];
        removed: T[];
    };
    protected getItems(): T[];
    protected getItem(storage: any, skipSettingToCache?: boolean): T;
    protected getItemStorage(item: any): any;
    protected reportObserved(): void;
    protected reportChanged(): void;
    protected triggerItemsChanged(args: CollectionChangedEventArgs<T>): void;
    get(index: number): T | undefined;
    set(index: number, item: T): T;
    add(): T;
    add(item: T): T;
    remove(item: T): boolean;
    clear(): void;
    readonly [Symbol.toStringTag]: 'Array';
    readonly [n: number]: T;
    get length(): number;
    set length(value: number);
    toString(): string;
    toLocaleString(): string;
    push(...items: T[]): number;
    pop(): T | undefined;
    concat(...items: T[]): T[];
    concat(...items: T[][]): T[];
    concat(...items: (T | T[])[]): T[];
    join(separator?: string): string;
    reverse(): this;
    shift(): T | undefined;
    slice(start?: number, end?: number): T[];
    sort(compareFn?: (a: T, b: T) => number): this;
    splice(start: number, deleteCount?: number): T[];
    splice(start: number, deleteCount: number, ...items: T[]): T[];
    unshift(...items: T[]): number;
    indexOf(searchElement: T, fromIndex?: number): number;
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;
    some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;
    forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;
    map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];
    filter(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): T[];
    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;
    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;
    find(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T | undefined;
    findIndex(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): number;
    fill(_value: T, _start?: number, _end?: number): this;
    copyWithin(_target: number, _start: number, _end?: number): this;
    [Symbol.iterator](): IterableIterator<T>;
    entries(): IterableIterator<[number, T]>;
    keys(): IterableIterator<number>;
    values(): IterableIterator<T>;
    [Symbol.unscopables](): {
        copyWithin: boolean;
        entries: boolean;
        fill: boolean;
        find: boolean;
        findIndex: boolean;
        keys: boolean;
        values: boolean;
    };
    at(index: number): T | undefined;
    readonly collectionChanged: EventHandler<(args: CollectionChangedEventArgs<T>) => void>;
    getStorage(): IStorageArray<T>;
    ensureCacheResolved(): void;
    clone(): ArrayStorage<T>;
    notifyStorageUpdated(): void;
    includes(searchElement: any, fromIndex?: number | undefined): boolean;
    flatMap(callback: any, thisArg?: any): any[];
    flat(depth: number | undefined): any[];
}
