/**
 * Представляет собой состояние жизненного цикла, в котором может находиться страница.
 */
export declare enum PageLifecycleState {
    /**
     * Страница находится в активном состоянии, если она видна и имеет фокус ввода.
     *
     * Возможные предыдущие состояния:
     * - passive.
     *
     * Возможные следующие состояния:
     * - passive.
     */
    active = "active",
    /**
     * Страница находится в пассивном состоянии, если она видна и не имеет фокуса ввода.
     *
     * В пассивном состоянии пользователь не взаимодействует со страницей, но все равно может ее видеть.
     * Это означает, что обновления пользовательского интерфейса и анимация должны быть плавными, но время, когда эти обновления происходят, менее критичны.
     * Когда страница меняется с активной на пассивную, самое время сохранить несохраненное состояние приложения.
     *
     * Возможные предыдущие состояния:
     * - active.
     * - hidden.
     *
     * Возможные следующие состояния:
     * - active.
     * - hidden.
     */
    passive = "passive",
    /**
     * Страница находится в скрытом состоянии, если она не видна и не была заморожена.
     * Данное состояние может возникать при переключении на другие вкладки или сворачивание браузера.
     *
     * Состояние может свидетельствовать о том, что со страницей больше не будут взаимодействовать. Но не говорит об этом однозначно.
     * Особенно это актуально на мобильном телефоне, так как пользователи могут свернуть/закрыть приложение или закрыть вкладку (в этих случаях однозначно ловиться hidden),
     * тогда браузер не вызывает события beforeunload, pagehide и unload, а значит переход к состоянию terminated не случится и состояние hidden останется последним.
     *
     * Это состояние можно рассматривать как потенциальное завершение работы страницы.
     * Например, если нужно очистить связанные с приложением ресурсы, то эту работу лучше выполнить в этом состоянии,
     * а если пользователь всё-таки продолжит работу со страницей (например, развернёт вкладку обратно),
     * поймать переход состояния hidden -> passive и восстановить ресурсы.
     * Или же, например, нужно отправить аналитические данные на сервер. Аналогично лучше отправить в этом состоянии,
     * а если потом обнаружится переход hidden -> passive, пометить отправленные данные как невалидные.
     *
     * Возможные предыдущие состояния:
     * - passive.
     *
     * Возможные следующие состояния:
     * - passive.
     * - frozen.
     * - terminated.
     */
    hidden = "hidden",
    /**
     * Страница находится в замороженном состоянии,
     * когда браузер приостанавливает выполнение замораживаемых задач в очереди задач до момента разморозки страницы (которая может и не случиться).
     * Браузеры замораживают страницы, чтобы снизить нагрузку на ЦП / батарею / данные; они также делают это, чтобы обеспечить более быструю навигацию.
     *
     * Уже запущенные задачи могут завершиться (наиболее приоритетны коллбеки события freeze),
     * но они могут быть ограничены в том, что они могут делать и как долго они могут работать.
     *
     * Важно, чтобы вы остановили любые таймеры или разорвали любые соединения,
     * которые в случае блокировки могут повлиять на другие открытые вкладки в том же источнике или повлиять на способность браузера
     * помещать страницу в Back-Forward Cache.
     *
     * В частности, важно, чтобы вы:
     *
     * - Закрыли все открытые соединения IndexedDB.
     * - Закрыли открытые соединения BroadcastChannel.
     * - Закрыли активные соединения WebRTC.
     * - Остановили любой опрос сети или закрыли все открытые подключения через веб-сокеты.
     * - Сняли любые удерживаемые веб-блокировки.
     *
     * Если страница переходит из замороженного обратно в скрытый, вы можете повторно открыть любые закрытые соединения или перезапустить любой опрос,
     * который вы остановили, когда страница была изначально заморожена.
  
     * Возможные предыдущие состояния:
     * - hidden.
     *
     * Возможные следующие состояния:
     * - active.
     * - passive.
     * - hidden.
     */
    frozen = "frozen",
    /**
     * Страница находится в завершенном состоянии после того, как она начала выгрузку и очистку из памяти браузером.
     * Это состояние однозначно говорит о том, что страница будет закрыта.
     *
     * Незавершенные задачи могут быть прерваны, если они выполняются слишком долго.
     * Выполняемый код должен быть синхронным и выполняться как можно быстрее, потребляя меньше ресурсов.
     *
     * Учтите, что данное состояние на мобильных устройствах происходит только если пользователь обновляет страницу или переходит в этой же вкладке по другому URL.
     * Если же пользователь закрывает вкладку/приложение, состояние не произойдет.
     * Поэтому, если необходимо выполнить работу перед закрытием страницы, рекомендуем рассмотреть состояние hidden.
     * Однако данное состояние является идеальным вариантом для очистки связанных с приложением ресурсов, которые потом нельзя восстановить.
     *
     * В случае необходимости отправки данных на сервер в этом состоянии не рекомендуется использовать асинхронные fetch, XMLHttpRequest,
     * так как не гарантируется, что запросы могут выполниться при закрытии страницы.
     * Вместо этого рекомендуется использовать механизм navigator.sendBeacon и POST-отправку.
     * Используйте готовые функции getOnPageClose и postOnPageClose.
     *
     * `FireFox не обрабатывает` никакие запросы на данной стадии, если открыта только одна вкладка браузера.
     * Если открыто две и более вкладок - запросы работают стабильно.
     *
     * Возможные предыдущие состояния:
     * - hidden.
     */
    terminated = "terminated"
}
/**
 * Представляет собой событие смены состояния жизненного цикла страницы.
 */
export declare class StateChangeEvent {
    /**
     * Состояние, на которое осуществился переход.
     */
    readonly newState: PageLifecycleState;
    /**
     * Состояние, с которого осуществился переход.
     */
    readonly oldState: PageLifecycleState;
    /**
     * Нативное событие, вызвавшее смену состояния.
     */
    readonly originalEvent: Event;
    constructor(oldState: PageLifecycleState, newState: PageLifecycleState, originalEvent: Event);
}
/**
 * Представляет собой механизм управления жизненным циклом страницы.
 */
export declare class PageLifecycle {
    private _state;
    private _stateWasChangedCallbacks;
    private _showConfirmBeforeUnload;
    private _safariBeforeUnloadTimeout;
    constructor();
    /**
     * Добавляет функцию обратного вызова, которая будет вызвана при смене состояния жизненного цикла страницы.
     * @param callback Функция обратного вызова, обрабатывающая смену состояния.
     * @param state Состояние или переход, при котором должна вызываться функция.
     * Если является типом PageLifecycleState, тогда функция будет вызываться каждый раз при переходе на указанное состояние.
     * Если является объектом, описывающим переход, тогда функция будет вызываться каждый раз в соответствии с указанным.
     * Если не указано вовсе, функция будет вызываться при каждой смене состояния.
     * @note При работе в состоянии terminated, код должен быть синхронным.
     * В случае необходимости отправки данных на сервер в этом состоянии не рекомендуется использовать асинхронные fetch, XMLHttpRequest,
     * так как не гарантируется, что запросы могут выполниться при закрытии страницы.
     * Вместо этого рекомендуется использовать механизм navigator.sendBeacon.
     * @returns Function Функцию, которая должна быть вызвана при необходимости отписки на события смены состояния.
     */
    addCallback(callback: (e: StateChangeEvent) => void, state?: PageLifecycleState | {
        fromState?: PageLifecycleState;
        toState?: PageLifecycleState;
    }): () => void;
    /**
     * Получает текущее состояние жизненного цикла страницы.
     */
    get state(): PageLifecycleState;
    /**
     * Получает признак того, что страница находится в удаленном состоянии.
     */
    get pageWasDiscarded(): boolean;
    /**
     * Получает признак необходимости показа диалога подтверждения перед выходом со страницы.
     */
    get showConfirmBeforeUnload(): boolean;
    /**
     * Устанавливает признак того, что необходимо показать диалог подтверждения перед выходом со страницы.
     */
    set showConfirmBeforeUnload(nextValue: boolean);
    private dispatchChangesIfNeeded;
    private dispatchEvent;
    private readonly handleNativeEvent;
    private readonly beforeUnloadShowConfirmHandler;
}
